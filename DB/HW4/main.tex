\documentclass[12pt,a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{xeCJK}
\usepackage{fontspec}
\setCJKmainfont{Noto Serif CJK TC}[Script=CJK]
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\setlength{\headheight}{14.5pt}
\addtolength{\topmargin}{-2.5pt}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{indentfirst}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{array}
\usepackage{tabularx}
\usepackage{float}
\usepackage{minted}
\setlength{\parindent}{2em}
\pagestyle{fancy}
\fancyhf{}
\cfoot{\thepage}
\linespread{1.3}
\setminted{
    linenos,                % 行號
    frame=lines,            % 上下框線
    framesep=5pt,           % 程式碼與邊框距離
    numbersep=8pt,          % 行號與程式碼距離
    fontsize=\scriptsize,   % 字體大小
    breaklines,             % 自動換行
    tabsize=4,              % tab 寬度
    rulecolor=\color{black},% 框線顏色
    xleftmargin=1.5em       % 左側縮排
}
\usepackage{pgffor} % for loop
\usepackage{subcaption} % for subfigure environment

\title{資料庫管理 HW04}
\author{B12508026戴偉璿}
\date{\today}

\begin{document}

\maketitle

\lhead{資料庫管理 HW04}
\rhead{B12508026戴偉璿}

\begin{enumerate}
    \item To check if PostgreSQL can avoid dirty read, I design two transactions:
    \begin{itemize}
        \item Transaction A: Update balance to 999 of account\_id 1
        \begin{minted}{sql}
            begin;
            update accounts set balance = 999 where account_id = 1;
            commit;
        \end{minted}
        \item Transaction B: Read the record.
        \begin{minted}{sql}
            begin; select * from accounts where account_id = 1; commit;
            
            
        \end{minted}
    \end{itemize}
    The execution steps are as follows:
    \begin{enumerate}
        \item Transaction A begins.
        \item Transaction A updates balance to 999 of account\_id 1, but does not commit yet.
        \item Transaction B begins.
        \item Transaction B reads the record of account\_id 1.
        \item Transaction B gets the old balance (not 999), which means dirty read is avoided.
        \item Transaction B commits.
        \item Transaction A commits.
        \item Transaction B begins.
        \item Transaction B reads the record of account\_id 1.
        \item Transaction B gets the new balance (999) after Transaction A commits.
        \item Transaction B commits.
    \end{enumerate}

    Following are the screenshots of each step. Left panel shows Transaction A, right panel shows Transaction B. Figure \ref{fig:1-1} shows the original status of the accounts table, we can see the balance of account\_id 1 is 1000. Figure \ref{fig:1-2} shows Transaction A updates balance to 999 of account\_id 1 but does not commit yet, so that Transaction B still reads the old balance (1000). Figure \ref{fig:1-3} shows Transaction A commits, and then Transaction B reads the new balance (999) of account\_id 1. You can determine the execution order by the system time shown in the top of each figure.
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{src/1-1.png}
        \caption{Orginal status of the accounts table}
        \label{fig:1-1}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{src/1-2.png}
        \caption{Transaction A updates balance to 999 of account\_id 1, but does not commit yet}
        \label{fig:1-2}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{src/1-3.png}
        \caption{Transaction A commits, Transaction B reads the new balance (999) of account\_id 1}
        \label{fig:1-3}
    \end{figure}

    With the experiments above, we can see that PostgreSQL can avoid dirty read.
    \item
    \begin{enumerate}
        \item A conflict occurs when two transactions access the same data item and at least one of the acceses is a write operation. For item $X$, three conflicts occurs between  $\{O_{11}, O_{23}\}$, $\{O_{17}, O_{21}\}$, $\{O_{17}, O_{23}\}$; for itme $Y$, there are no conflicts; for item $Z$, two conflicts occurs between $\{O_{15}, O_{24}\}$, $\{O_{15}, O_{26}\}$.
        \item The serial schedule of $T_2 \rightarrow T_1$ is as follows:
        $$
        O_{21}\rightarrow O_{23}\rightarrow O_{24}\rightarrow O_{26}\rightarrow
        O_{11}\rightarrow O_{12}\rightarrow O_{13}\rightarrow O_{15}\rightarrow O_{17}.
        $$

        To analyze the conflicting operation pairs, we can discuss by data items:

        For item $X$, the operation order must obey: $O_{21}\prec O_{23}\prec O_{17}$, $O_{23}\prec O_{11}\prec O_{17}$

        For item $Y$, there are no conflicts, so there is no constraint.

        For item $Z$, the operation order must obey: $O_{24}\prec O_{26}\prec O_{15}$

        Therefore, one such conflict-equivalent non-serial schedule is:
        $$
        O_{21}\rightarrow O_{23}\rightarrow O_{11}\rightarrow 
        O_{24}\rightarrow O_{26}\rightarrow 
        O_{12}\rightarrow O_{13}\rightarrow O_{15}\rightarrow O_{17}.
        $$

        \item The serial schedule of $T_1 \rightarrow T_2$ is as follows:
        $$
        O_{11}\rightarrow O_{12}\rightarrow O_{13}\rightarrow O_{15}\rightarrow O_{17}\rightarrow
        O_{21}\rightarrow O_{23}\rightarrow O_{24}\rightarrow O_{26}.
        $$

        Consider the last operation of $T_1$ and the first operation of $T_2$, we have $O_{17}\prec O_{21}$ because $O_{17}$ is the write operation and they access the same data item $X$.
        
        To maintain the order within the transactions, $O_{17}$ must be the last operation in the schedule and $O_{21}$ must be the first operation in the schedule. From the analyze above, $O_{21}$ must after $O_{17}$. Therefore, there is no such conflict-equivalent non-serial schedule.
    \end{enumerate}
    \item Lost update often occurs when two transactions read the same version of a data item and then update it based on that old value. This causes one update to overwrite the other, resulting in one update being lost. To address this issue, we can acquire a read lock before reading the data item so that other transactions cannot write to it until the read lock is released. This prevents the read operation from being interfered with by concurrent writes. Before updating the data, we can upgrade the read lock to a write lock to prevent other transactions from reading or writing the item until the write lock is released. This prevents other transactions from accessing the data while it is being updated, ensuring data integrity.
    \item 
    \begin{enumerate}
        \item This SQL statement querys the top 10 reserved sales departure from station id 1030 and arrival station id 1000 at 2023-08-01.
    \end{enumerate}
\end{enumerate}

\end{document}