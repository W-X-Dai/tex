\documentclass[12pt,a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{xeCJK}
\usepackage{fontspec}
\setCJKmainfont{Noto Serif CJK TC}[Script=CJK]
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\setlength{\headheight}{14.5pt}
\addtolength{\topmargin}{-2.5pt}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{indentfirst}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{array}
\usepackage{tabularx}
\usepackage{float}
\usepackage{minted}
\setlength{\parindent}{2em}
\pagestyle{fancy}
\fancyhf{}
\cfoot{\thepage}
\linespread{1.3}
\setminted{
    linenos,                % 行號
    frame=lines,            % 上下框線
    framesep=5pt,           % 程式碼與邊框距離
    numbersep=8pt,          % 行號與程式碼距離
    fontsize=\scriptsize,   % 字體大小
    breaklines,             % 自動換行
    tabsize=4,              % tab 寬度
    rulecolor=\color{black},% 框線顏色
    xleftmargin=1.5em       % 左側縮排
}
\usepackage{pgffor} % for loop
\usepackage{subcaption} % for subfigure environment

\title{資料庫管理 HW05}
\author{B12508026戴偉璿}
\date{\today}

\begin{document}

\maketitle

\lhead{資料庫管理 HW05}
\rhead{B12508026戴偉璿}

\begin{enumerate}
    \item If we read the outer loop into $B-2$ blocks, the total cost is $M$(number of outer blocks)$+ \lceil\frac{M}{B-2}\rceil \times N$(number of inner loop read times). Thus, the total cost is $\lceil\frac{M}{B-2}\rceil \times N + M$ I/Os. In the other way, if we read the inner loop into $B-2$ blocks, the total cost is $N + \lceil\frac{N}{B-2}\rceil \times M$ I/Os. Therefore, the total cost is $\min(\lceil\frac{M}{B-2}\rceil \times N + M, N + \lceil\frac{N}{B-2}\rceil \times M)$ I/Os. Thus, these two methods are roughly equal. However, in practical, we usually put smaller relation in the outer loop to reduce the number of passes of the inner loop. In this case, place the smaller relation into $B-2$ blocks is better.
    \item \
    \begin{enumerate}
        \item I don't think this plan is more efficient. There are no join keys between \texttt{PRODUCT} and \texttt{SALES}. If we join these two relations first, it would cause cartesian product, which would produce a very large intermediate relation.
        \item\sloppy To achieve projection pushdown, I project the needed attributes at the first step. Next step would be handle the predicate pushdown. I apply the selection \texttt{s.store\_id=1} and \texttt{sd,unit\_price>=20} at this phase. Now I need to decide which join should be performed first. I have two joins: \texttt{PRODUCT} $\bowtie$ \texttt{SALES\_DETAIL} and \texttt{SALES} $\bowtie$ \texttt{SALES\_DETAIL}. Any way, \texttt{SALES\_DETAIL} must be joined first. Thus, I need to choose between \texttt{PRODUCT} $\bowtie$ \texttt{SALES\_DETAIL} and \texttt{SALES} $\bowtie$ \texttt{SALES\_DETAIL}. Finally I decide to join \texttt{SALES} and \texttt{SALES\_DETAIL} first because there is a selection \texttt{s.store\_id=1} on \texttt{SALES}, which would reduce the number of tuples in the intermediate relation. Besides, the join key \texttt{receipt\_no} may be more selective than \texttt{product\_id}. The overall plan is shown as Fig~.\ref{fig: 2b}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=1\textwidth]{src/2b.png}
            \caption{Query Plan with Projection and Predicate Pushdown}
            \label{fig: 2b}
        \end{figure}
        \item The query plan generated by postgreSQL is shown as Fig~.\ref{fig: 2c}.
        \begin{figure}[H]
            \centering
            \includegraphics[width=1\textwidth]{src/2c.png}
            \caption{Query Plan Generated by PostgreSQL}
            \label{fig: 2c}
        \end{figure}
        The DBMS first pushes down the filters so that the tables become smaller before any joins.
        Then it estimates how many rows remain after each step and chooses the join order that keeps the intermediate results as small as possible.
        This is why it joins \texttt{SALES\_DETAIL} and \texttt{SALES} first using a Hash Join, and only later joins \texttt{PRODUCT} using an index.
        \item The query plan of this query is same as Fig~.\ref{fig: 2c}. 
    \end{enumerate}
    % 3
    \item 
    \begin{enumerate}
        \item 
    \end{enumerate}
    % 4
    \item ACID refers to Atomicity, Consistency, Isolation, and Durability, they guarantee that database transactions are processed reliably. BASE refers to Basically Available, Soft state, Eventual consistency, which is an alternative to the ACID model for database systems that prioritize availability over strict consistency. In summary, ACID focuses on ensuring data integrity and reliability through strict transaction management, while BASE emphasizes system availability and scalability by allowing for eventual consistency.
\end{enumerate}
\end{document}
