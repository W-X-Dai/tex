\documentclass[12pt,a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{xeCJK}
\usepackage{fontspec}
\setCJKmainfont{Noto Serif CJK TC}[Script=CJK]
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\setlength{\headheight}{14.5pt}
\addtolength{\topmargin}{-2.5pt}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{indentfirst}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{array}
\usepackage{tabularx}
\usepackage{float}
\usepackage{minted}
\setlength{\parindent}{2em}
\pagestyle{fancy}
\fancyhf{}
\cfoot{\thepage}
\linespread{1.3}
\setminted{
    linenos,                % 行號
    frame=lines,            % 上下框線
    framesep=5pt,           % 程式碼與邊框距離
    numbersep=8pt,          % 行號與程式碼距離
    fontsize=\scriptsize,   % 字體大小
    breaklines,             % 自動換行
    tabsize=4,              % tab 寬度
    rulecolor=\color{black},% 框線顏色
    xleftmargin=1.5em       % 左側縮排
}
\usepackage{pgffor} % for loop
\usepackage{subcaption} % for subfigure environment

\title{資料庫管理 HW04}
\author{B12508026戴偉璿}
\date{\today}

\begin{document}

\maketitle

\lhead{資料庫管理 HW04}
\rhead{B12508026戴偉璿}

\begin{enumerate}
    \item To check if PostgreSQL can avoid dirty read, I design two transactions:
    \begin{itemize}
        \item Transaction A: Update balance to 999 of account\_id 1
        \begin{minted}{sql}
            begin;
            update accounts set balance = 999 where account_id = 1;
            commit;
        \end{minted}
        \item Transaction B: Read the record.
        \begin{minted}{sql}
            begin; select * from accounts where account_id = 1; commit;
            
            
        \end{minted}
    \end{itemize}
    The execution steps are as follows:
    \begin{enumerate}
        \item Transaction A begins.
        \item Transaction A updates balance to 999 of account\_id 1, but does not commit yet.
        \item Transaction B begins.
        \item Transaction B reads the record of account\_id 1.
        \item Transaction B gets the old balance (not 999), which means dirty read is avoided.
        \item Transaction B commits.
        \item Transaction A commits.
        \item Transaction B begins.
        \item Transaction B reads the record of account\_id 1.
        \item Transaction B gets the new balance (999) after Transaction A commits.
        \item Transaction B commits.
    \end{enumerate}

    Following are the screenshots of each step. Left panel shows Transaction A, right panel shows Transaction B. Figure \ref{fig:1-1} shows the original status of the accounts table, we can see the balance of account\_id 1 is 1000. Figure \ref{fig:1-2} shows Transaction A updates balance to 999 of account\_id 1 but does not commit yet, so that Transaction B still reads the old balance (1000). Figure \ref{fig:1-3} shows Transaction A commits, and then Transaction B reads the new balance (999) of account\_id 1. You can determine the execution order by the system time shown in the top of each figure.
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{src/1-1.png}
        \caption{Orginal status of the accounts table}
        \label{fig:1-1}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{src/1-2.png}
        \caption{Transaction A updates balance to 999 of account\_id 1, but does not commit yet}
        \label{fig:1-2}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{src/1-3.png}
        \caption{Transaction A commits, Transaction B reads the new balance (999) of account\_id 1}
        \label{fig:1-3}
    \end{figure}

    With the experiments above, we can see that PostgreSQL can avoid dirty read.
    \item
    \begin{enumerate}
        \item A conflict occurs when two transactions access the same data item and at least one of the acceses is a write operation. For item $X$, three conflicts occurs between  $\{O_{11}, O_{23}\}$, $\{O_{17}, O_{21}\}$, $\{O_{17}, O_{23}\}$; for itme $Y$, there are no conflicts; for item $Z$, two conflicts occurs between $\{O_{15}, O_{24}\}$, $\{O_{15}, O_{26}\}$.
        \item The serial schedule of $T_2 \rightarrow T_1$ is as follows:
        $$
        O_{21}\rightarrow O_{23}\rightarrow O_{24}\rightarrow O_{26}\rightarrow
        O_{11}\rightarrow O_{12}\rightarrow O_{13}\rightarrow O_{15}\rightarrow O_{17}.
        $$

        To analyze the conflicting operation pairs, we can discuss by data items:

        For item $X$, the operation order must obey: $O_{21}\prec O_{23}\prec O_{17}$, $O_{23}\prec O_{11}\prec O_{17}$

        For item $Y$, there are no conflicts, so there is no constraint.

        For item $Z$, the operation order must obey: $O_{24}\prec O_{26}\prec O_{15}$

        Therefore, one such conflict-equivalent non-serial schedule is:
        $$
        O_{21}\rightarrow O_{23}\rightarrow O_{11}\rightarrow 
        O_{24}\rightarrow O_{26}\rightarrow 
        O_{12}\rightarrow O_{13}\rightarrow O_{15}\rightarrow O_{17}.
        $$

        \item The serial schedule of $T_1 \rightarrow T_2$ is as follows:
        $$
        O_{11}\rightarrow O_{12}\rightarrow O_{13}\rightarrow O_{15}\rightarrow O_{17}\rightarrow
        O_{21}\rightarrow O_{23}\rightarrow O_{24}\rightarrow O_{26}.
        $$

        Consider the last operation of $T_1$ and the first operation of $T_2$, we have $O_{17}\prec O_{21}$ because $O_{17}$ is the write operation and they access the same data item $X$.
        
        To maintain the order within the transactions, $O_{17}$ must be the last operation in the schedule and $O_{21}$ must be the first operation in the schedule. From the analyze above, $O_{21}$ must after $O_{17}$. Therefore, there is no such conflict-equivalent non-serial schedule.
    \end{enumerate}
    \item Lost update often occurs when two transactions read the same version of a data item and then update it based on that old value. This causes one update to overwrite the other, resulting in one update being lost. To address this issue, we can acquire a read lock before reading the data item so that other transactions cannot write to it until the read lock is released. This prevents the read operation from being interfered with by concurrent writes. Before updating the data, we can upgrade the read lock to a write lock to prevent other transactions from reading or writing the item until the write lock is released. This prevents other transactions from accessing the data while it is being updated, ensuring data integrity.
    \item 
    \begin{enumerate}
        \item This SQL statement queries the top 10 reserved sales for trips that depart from station\_id 1030 and arrive at station\_id 1000 during the period from 2023-08-01 to 2023-08-31, and the train must depart after 06:00. It joins the PASS table with itself on trip\_id, where p1 represents the departure station (1030) and p2 represents the arrival station (1000). After joining, it selects each trip’s departure and arrival time, and uses a subquery to count how many tickets were reserved for that same trip and same station pair within the specified date range. Finally, the results are ordered by departure time and limited to the first 10 row
        \item Following is hte query plan generated by PostgreSQL for the SQL statement above, the estimated cost is 560.17.
        \begin{minted}{sql}
 Limit  (cost=66.83..196.66 rows=10 width=28)
   ->  Result  (cost=66.83..560.17 rows=38 width=28)
         ->  Sort  (cost=66.83..66.93 rows=38 width=20)
               Sort Key: p1.depart_time
               ->  Hash Join  (cost=35.44..66.01 rows=38 width=20)
                     Hash Cond: (p2.trip_id = p1.trip_id)
                     Join Filter: (p1.depart_time < p2.arrive_time)
                     ->  Seq Scan on pass p2  (cost=0.00..30.06 rows=195 width=12)
                           Filter: (station_id = 1000)
                     ->  Hash  (cost=34.08..34.08 rows=109 width=12)
                           ->  Seq Scan on pass p1  (cost=0.00..34.08 rows=109 width=12)
                                 Filter: ((depart_time > '06:00:00'::time without time zone) AND (station_id = 1030))
         SubPlan 1
           ->  Aggregate  (cost=12.96..12.97 rows=1 width=8)
                 ->  Index Only Scan using idx_trip_id_on_reserved_ticket on reserved_ticket  (cost=0.43..12.58 rows=151 width=0)
                       Index Cond: ((trip_id = p1.trip_id) AND (arrive_station_id = 1000) AND (depart_station_id = 1030) AND (travel_date >= '2023-08-01'::date) AND (travel_date <= '2023-08-31'::date))
            
        \end{minted}
        
        \item Following is the code to create index on \texttt{trip\_id}, \texttt{depart\_station\_id},\\ and \texttt{arrive\_station\_id}:   
        \begin{minted}{sql}
create index idx_trip_id on pass(trip_id);

create index idx_depart_station_id on reserved_ticket(depart_station_id);

create index idx_arrive_station_id on reserved_ticket(arrive_station_id);
        \end{minted}
        Following is the query plan after creating index on \texttt{trip\_id}
        \begin{minted}{sql}
 Limit  (cost=66.83..196.66 rows=10 width=28)
   ->  Result  (cost=66.83..560.17 rows=38 width=28)
         ->  Sort  (cost=66.83..66.93 rows=38 width=20)
               Sort Key: p1.depart_time
               ->  Hash Join  (cost=35.44..66.01 rows=38 width=20)
                     Hash Cond: (p2.trip_id = p1.trip_id)
                     Join Filter: (p1.depart_time < p2.arrive_time)
                     ->  Seq Scan on pass p2  (cost=0.00..30.06 rows=195 width=12)
                           Filter: (station_id = 1000)
                     ->  Hash  (cost=34.08..34.08 rows=109 width=12)
                           ->  Seq Scan on pass p1  (cost=0.00..34.08 rows=109 width=12)
                                 Filter: ((depart_time > '06:00:00'::time without time zone) AND (station_id = 1030))
         SubPlan 1
           ->  Aggregate  (cost=12.96..12.97 rows=1 width=8)
                 ->  Index Only Scan using idx_trip_id_on_reserved_ticket on reserved_ticket  (cost=0.43..12.58 rows=151 width=0)
                       Index Cond: ((trip_id = p1.trip_id) AND (arrive_station_id = 1000) AND (depart_station_id = 1030) AND (travel_date >= '2023-08-01'::date) AND (travel_date <= '2023-08-31'::date))
        \end{minted}

        Following is the query plan after creating index on \texttt{depart\_station\_id}:
        \begin{minted}{sql}
 Limit  (cost=66.83..196.66 rows=10 width=28)
   ->  Result  (cost=66.83..560.17 rows=38 width=28)
         ->  Sort  (cost=66.83..66.93 rows=38 width=20)
               Sort Key: p1.depart_time
               ->  Hash Join  (cost=35.44..66.01 rows=38 width=20)
                     Hash Cond: (p2.trip_id = p1.trip_id)
                     Join Filter: (p1.depart_time < p2.arrive_time)
                     ->  Seq Scan on pass p2  (cost=0.00..30.06 rows=195 width=12)
                           Filter: (station_id = 1000)
                     ->  Hash  (cost=34.08..34.08 rows=109 width=12)
                           ->  Seq Scan on pass p1  (cost=0.00..34.08 rows=109 width=12)
                                 Filter: ((depart_time > '06:00:00'::time without time zone) AND (station_id = 1030))
         SubPlan 1
           ->  Aggregate  (cost=12.96..12.97 rows=1 width=8)
                 ->  Index Only Scan using idx_trip_id_on_reserved_ticket on reserved_ticket  (cost=0.43..12.58 rows=151 width=0)
                       Index Cond: ((trip_id = p1.trip_id) AND (arrive_station_id = 1000) AND (depart_station_id = 1030) AND (travel_date >= '2023-08-01'::date) AND (travel_date <= '2023-08-31'::date))

        \end{minted}

        Following is the query plan after creating index on \texttt{arrive\_station\_id}:
        \begin{minted}{sql}
 Limit  (cost=66.83..196.66 rows=10 width=28)
   ->  Result  (cost=66.83..560.17 rows=38 width=28)
         ->  Sort  (cost=66.83..66.93 rows=38 width=20)
               Sort Key: p1.depart_time
               ->  Hash Join  (cost=35.44..66.01 rows=38 width=20)
                     Hash Cond: (p2.trip_id = p1.trip_id)
                     Join Filter: (p1.depart_time < p2.arrive_time)
                     ->  Seq Scan on pass p2  (cost=0.00..30.06 rows=195 width=12)
                           Filter: (station_id = 1000)
                     ->  Hash  (cost=34.08..34.08 rows=109 width=12)
                           ->  Seq Scan on pass p1  (cost=0.00..34.08 rows=109 width=12)
                                 Filter: ((depart_time > '06:00:00'::time without time zone) AND (station_id = 1030))
         SubPlan 1
           ->  Aggregate  (cost=12.96..12.97 rows=1 width=8)
                 ->  Index Only Scan using idx_trip_id_on_reserved_ticket on reserved_ticket  (cost=0.43..12.58 rows=151 width=0)
                       Index Cond: ((trip_id = p1.trip_id) AND (arrive_station_id = 1000) AND (depart_station_id = 1030) AND (travel_date >= '2023-08-01'::date) AND (travel_date <= '2023-08-31'::date))
     
        \end{minted}
    \end{enumerate}
\end{enumerate}

\end{document}